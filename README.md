# C/C++ 笔记

这是我的C语言学习笔记，记录一些我自己的学习经历和一些遇到的问题。

## C语言基础
### 一、字符和字符串
#### 1、字符串是结尾为'\0'的数组。
#### 2、关于字符和字符串引号的使用：
* 字符类型只能用单引号' '。
* 字符串类型用双引号" "（结尾为'\0'的数组）。
```c
char ch = 'A';
char str[10] = "Hello";
```
### 二、数组
数组字符串初始化:memset。
### 三、指针
#### 1、void* 无类型指针
void* 是一个无类型指针，指针变量都占4byte内存。<br>
（1）void* 可以接受任何类型的赋值：
>任何类型的指针都可以直接赋值给void* 型指针，无需进行强制类型转换，相当于void* 包含了其他类型的指针。<br>

（2）void* 可以赋值给任何类型的变量：
>需要进行强制转换，因为void* 的范围较大，所以强制转换使其进行范围缩小。 <br>

### 四、结构体
结构体数组每一个元素才是结构体。
### 五、动态内存
#### 1、内存分配操作
malloc函数：分配连续的内存空间。<br>
```c
void *malloc(size_t size);
返回值：成功返回分配的内存空间指针，失败返回空指针BULL
```
free函数：释放内存，内存使用完后一定要调用free释放内存。<br>
```c
void free(void *ptr);
```
2、内存分配可能出现的问题
  内存耗尽：分配空间使用完毕后一定要及时释放内存。
  野指针：无效指针。
>野指针产生原因：<br>
>1、定义指针未初始化。<br>
>2、指针释放后未置空； 释放内存后应将指针置位0。<br>
### 六、文件操作
#### 1、文件指针定义
```c
FILE *fp;
```
#### 2、文件操作函数<br>
>fopen()：打开文件。<br>
>fclose()：关闭文件，释放内存（文件使用完后一定要关闭文件释放内存！）。<br>

>fprintf()：向文件中写入数据。<br>
>fgets()：从文件中读取数据。<br>
>fputs()：向文件中写入数据。<br>

>fwrite()：向二进制文件写入数据。<br>
>fread()：从二进制文件读取数据。<br>

文件定位<br>
>ftell：返回当前文件位置指针的值。<br>
>rewind：将文件位置指针移动到文件开头。<br>
>fseek：将文件指针移动到人任意位置。<br>

#### 3、文件缓冲区
调用fputs、fwrite等函数向文件写入数据时，数据不会立即写入磁盘文件，而是先写入缓冲区文件，等缓冲区写满后才写入磁盘文件。调用fclose时也会将把缓冲区数据写入文件。<br>
>fflush：可以立即将缓冲区数据写入文件。<br>

### 七、目录操作
#### 1、目录指针定义
```c
DIR *dir;
```
#### 2、目录函数
头文件
```c
#include<dirent.h>
```
>opendir()：打开目录函数。<br>
>closedir()：关闭目录函数，一定要关闭目录！<br>
>readdir()：读取目录函数，返回一个结构体，包含读取到的文件和目录的信息。<br>
>>readdir返回的结构体重包含了文件和目录信息。如文件名、文件类型等。<br>

>access：判断当前操作系统用户对文件或目录的存取权限。（头文件unistd.h（unix的库））<br>
>utime()：有结构体utimbuf，修改文件的存取时间和修改时间。<br>
>remane()：修改文件或目录名称。<br>
>remove()：删除文件或目录。<br>
>stat结构体：存放文件或目录的状态信息。 <br>

### 八、函数
#### 1、编译预处理
1）include：包含文件，<>标准头文件；""指定目录文件（自己写的文件），可以加入.C的文件。<br>
2）define：定义宏。<br>
>无参数宏：相当于替换；<br>
>带参数宏；<br>
3）条件编译：ifdef和ifndef，在预编译的时候判断。ifndef，用来防止重复包含头文件。<br>
#### 2、main函数参数：argc,argv,envp
```c
int main(int argc,char *argv[],char *envp[])
```
>argc：存放命令行参数个数。<br>
>argv：字符串数组，每个元素都是一个字符指针，指向一个字符串，即命令行的每一个参数。<br>
>envp：字符串数组，每个元素都是一个字符指针，指向一个环境变量参数。<br>
#### 3、时间操作函数
>time()：返回从1970.1.1的0时0分0秒到现在的秒数。<br>

  time_t数据类型：表示时间数据类型，是一个long（长整数）类型别名。头文件件time.h。表示一个日历时间，从1970.1.1的0时0分0秒到现在的秒数。
  tm结构体：方便表示时间的结构体。
  localtime库函数：把time_t表示的时间转换为结构体tm表示的时间。
  mktime库函数：把结构体tm表示的时间转为time_t表示的时间。进行时间运算时time_t整数比字符串好用。<br>

程序睡眠：<br>
头文件unistd.h（该函数库是unix的库）<br>
```c
#include<unistd.h>
```
>sleep()：程序睡眠，单位秒；<br>
>usleep()：程序睡眠，单位微秒。<br>
 
计时器：
头文件sys/time.h（该函数库是unix的库）<br>
```c
#include<sys/time.h>
```
  timeval结构体：从1970.1.1到现在的秒数或微秒数。
  timezone结构体：时区结构体，与格林威时间差多少。
  gettimeofday库函数：从1970.1.1到现在的秒数，和当前秒已经逝去的微秒数。<br>
#### 4、系统错误函数
errno全局变量：库函数返回错误码会存入errno全局变量中，错误码对应的错误消息定义在errno.h头文件中。<br>
>strerror()：根据错误码显示错误描述。<br>
>perror()：用于在屏幕上显示最近一次错误码和消息描述。<br>

重点：<br>
>1）不是所有库函数失败都会设置errno值。不属于系统调用的函数不会设置errno。<br>
>2）errno不能作为调用库函数失败的标志。如果库函数正确的执行，那么errno的值不会被清零，只有库函数发生错误时才会设置。<br>
#### 4、printf输出函数
```c
printf("%d",*p);
```
输出整数型（%d）时，函数要求你提供一个整数型（int），而p是一个指针，填入p将把指针内的地址输出。<br>
```c
printf("%s",p);
```
输出字符串（%s）时，函数要求你提供一个指针，而p就是一个指针变量，可以直接写变量名p。<br>
#### 5、关于函数传入参数为一个指针
```c
void set(char* p);
```
该函数参数为一个char型指针p，当调用该函数时，我们需要传入的是一个指针变量p。即可以看作
```c
void set((char* ) p);
```
该函数需要一个（char* ）型的变量p（指针变量）。<br>
<br>
<br>
<br>

## C++语言基础
### 一、C++程序命名
C++头文件一般用.h或.hpp后缀。
C++程序文件一般用.cpp或.cc后缀。
### 二、C++输入和输出
C的输入输出可以可以在C++中，C++新增cin/cout输入输出库。
### 三、C++支持布尔类型（bool）。
### 四、C++可以为函数指定缺省参数，缺省参数只能放在非缺省参数后面。
### 五、C++动态内存分配：new分配/delete释放。
### 六、C++函数重载
C++允许多个函数拥有相同名字，只要参数列表不同就可以了。函数的参数列表又叫参数签名，包含参数类型、参数个数、参数顺序，只要有一个不同就是参数列表不同。
### 七、C++类
#### 1、类与结构体
类也是一种结构体，可以看做C结构体的升级版，类的成员不但可以有变量，还可以有函数，定义的类变量（结构体变量）称为对象（或者说是实例化一个对象）。<br>
对象（类变量）=结构体变量；属性=结构体成员变量；<br>
1）类是一个模板，类的成员变量是不能赋值的。<br>
2）类的成员函数,它可以直接访问类的成员变量。<br>
3）我对类成员变量命名一般以m_打头。<br>
4）类可以定义为一个全局变量。<br>
5）对象数组、指针和结构体数组、指针一样。<br>
6）对象也可以用sizeof计算所占内存大小。<br>
#### 2、类的访问权限
1）三个关键字public、private、protected控制成员变量和成员函数的访问权限。<br>
2）在类的内部，没有访问限制。<br>
3）在类的外部，只能通过对象访问public的成员变量和函数。<br>
#### 3、构造函数
1）构造函数名与类名相同。<br>
2）构造函数没有返回值，即函数名前什么也不加。<br>
3）构造函数不能被显式的调用。<br>
4）构造函数在创建对象时自动执行。<br>
5）可以用构造函数来进行初始化工作；<br>
6）可以重载。<br>
#### 4、析构函数
1）析构函数名字前加上~；<br>
2）析构函数没有返回值；<br>
3）析构函数可以被显式的调用；<br>
4）在对象销毁时自动执行，用于清理工作，如释放内存，关闭文件等。<br>
5）不可以重载，一个类只能有一个析构函数。<br>
#### 5、类的对象可作为参数传入函数用类指针。
### 八、可变参数
printf、fprintf、sprintf、snprintf函数参数列表是可变的。
### 九、引用
“&"符在C++中除了取地址还有引用的作用。引用就是某一变量的别名，对引用的操作与对变量操作是一样的。
```c++
int a;
int &ra = a;
```
1）类型标识符是指目标变量的类型；<br>
2）声明引用时，必须同时对其初始化；<br>
3）不能建立数组引用；<br>
4）引用别名不占用内存；<br>
5）引用别名可以用const进行修饰，引用用const修饰后，目标变量可以更改，别名不行。<br>
### 十、string类
#### 1、string类的头文件string；<br>
#### 2、string类是一个模板类，位于std命名空间内。创建string类的对象，需要加上命名空间：
```c++
using namespace std
````
或者在定义字符串对象时使用：
```c++
std::stirng str;
```
#### 3、c_str()函数：将string转换为一个c字符串，返回一个以NULL结尾的c字符串，即返回一个指向正规c字符串的指针。<br>
>size()、length()：返回字符串大小；<br>
>clear()：清空字符串。<br>
#### 4、string类通过动态分配内存，实现字符串的存储，所以string对象内存地址是变化的。由于string的内存空间不固定，string类最好用于存放临时数据。
### 十一、vector容器
1、vector是一个封装了动态数组的顺序容器，可以存放各种类型的数据和对象。简单来说就是一个可以存放任意类型的动态数组。与数组相比，vector可以根据需要自动调整大小。<br>
2、vector头文件<vector>，vector是一个模板类，也需要std命名空间 using namespace std。<br>
3、函数clear()：清空容器内的全部元素。<br>
1）容器被声明时就是空的；<br>
2）容器是类，有析构函数，析构函数会自动清空容器中的元素，释放资源。<br>
### 十二、运算符重载
### 十三、继承
继承允许根据一个类来定义另一个类，打到代码功能重用的效果。当一个待创建的类与另一个类有某些共同特征，继承可以使我们不用全部重写成员变量和成员函数，只需指定继承一个类即可，被继承的类称为基类或父类，新建的类称为派生类或子类。<br>
#### 1、定义派生类需要指定它的父类：
	
```c++ 
class derived-class: access-specifier base-class
```
#### 2、派生类可以继承父类中所有public和protected成员变量和成员函数。父类中的private的成员不能被继承，但可以通过父类中的public和protected成员访问。<br>
#### 3、基类指针可以指向派生类对象，但是不能通过基类的指针访问派生类成员；派生类指针不能指向基类对象。<br>
#### 4、多继承，一个派生类可以继承多个基类。<br>
### 十四、多态
程序可以有多个不同的类，且每个类可以都有一个名称相同但具有不同实现的函数。 
#### 1、虚函数
在父类中使用virtual关键字声明的函数 。在子类重新定义父类中定义的虚函数时（父类虚函数为virtual A，派生类为A），会告诉编译器不要静态链接到父类该函数（virtual A），用指针调用函数A时会直接调用子类的函数A。
#### 2、纯虚函数：
父类中定义
```c++
virtual A=0。
```
1）父类中的纯虚函数只是对函数进行了声明，没有定义。<br>
2）定义有纯虚函数的父类就是用来被继承，即规定每个继承的子类都要有这个函数。<br>
3）父类中有纯虚函数，则这个类不能用来实例化对象（定义对象）。<br>
#### 3、C++接口（抽象类）
接口描述了类的行为和功能，是标准和规范，而不需要完成类的功能实现。拥有一个纯虚函数这个类就是抽象类。<br>
1）抽象类的目的就是为了给其他类提供一个可以继承的父类。<br>
2）抽象类不能被实例化，只能作为接口使用。<br>
3）一个父类的子类想要被实例化（定义），必须要实现父类中的每一个虚函数（和纯虚函数），这意味着C++支持使用父类声明接口。如果子类没有重写（定义实现）纯虚函数，就尝试实例化该类对象，就会导致编译错误。<br>
4）可以用于实例化对象的类称为具体类。<br>
### 十五、数据封装
数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。<br>
C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。<br>
